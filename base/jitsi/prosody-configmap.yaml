kind: ConfigMap
apiVersion: v1
metadata:
  namespace: jitsi
  name: prosody
data:
  mod_prometheus.lua:  |
    -- Log statistics to Prometheus
    --
    -- Copyright (C) 2014 Daurnimator
    -- Copyright (C) 2018 Emmanuel Gil Peyrot <linkmauve@linkmauve.fr>
    --
    -- This module is MIT/X11 licensed.
    module:set_global();
    local tostring = tostring;
    local t_insert = table.insert;
    local t_concat = table.concat;
    local socket = require "socket";
    local get_stats = require "core.statsmanager".get_stats;
    local function escape(text)
      return text:gsub("\\", "\\\\"):gsub("\"", "\\\""):gsub("\n", "\\n");
    end
    local function escape_name(name)
      return name:gsub("[^A-Za-z0-9_]", "_"):gsub("^[^A-Za-z_]", "_%1");
    end
    local function get_timestamp()
      -- Using LuaSocket for that because os.time() only has second precision.
      return math.floor(socket.gettime() * 1000);
    end
    local function repr_help(metric, docstring)
      docstring = docstring:gsub("\\", "\\\\"):gsub("\n", "\\n");
      return "# HELP "..escape_name(metric).." "..docstring.."\n";
    end
    -- local allowed_types = { counter = true, gauge = true, histogram = true, summary = true, untyped = true };
    -- local allowed_types = { "counter", "gauge", "histogram", "summary", "untyped" };
    local function repr_type(metric, type_)
      -- if not allowed_types:contains(type_) then
      --   return;
      -- end
      return "# TYPE "..escape_name(metric).." "..type_.."\n";
    end
    local function repr_label(key, value)
      return key.."=\""..escape(value).."\"";
    end
    local function repr_labels(labels)
      local values = {}
      for key, value in pairs(labels) do
        t_insert(values, repr_label(escape_name(key), escape(value)));
      end
      if #values == 0 then
        return "";
      end
      return "{"..t_concat(values, ", ").."}";
    end
    local function repr_sample(metric, labels, value, timestamp)
      return escape_name(metric)..repr_labels(labels).." "..value.." "..timestamp.."\n";
    end
    local allowed_extras = { min = true, max = true, average = true };
    local function insert_extras(data, key, name, timestamp, extra)
      if not extra then
        return false;
      end
      local has_extra = false;
      for extra_name in pairs(allowed_extras) do
        if extra[extra_name] then
          local field = {

            value = extra[extra_name],
            labels = {

              ["type"] = name,
              field = extra_name,
            },
            typ = "gauge";
            timestamp = timestamp,
          };
          t_insert(data[key], field);
          has_extra = true;
        end
      end
      return has_extra;
    end
    local function parse_stats()
      local timestamp = tostring(get_timestamp());
      local data = {};
      local stats, changed_only, extras = get_stats();
      for stat, value in pairs(stats) do
        -- module:log("debug", "changed_stats[%q] = %s", stat, tostring(value));
        local extra = extras[stat];
        local host, sect, name, typ = stat:match("^/([^/]+)/([^/]+)/(.+):(%a+)$");
        if host == nil then
          sect, name, typ = stat:match("^([^.]+)%.(.+):(%a+)$");
        elseif host == "*" then
          host = nil;
        end
        if sect:find("^mod_measure_.") then
          sect = sect:sub(13);
        elseif sect:find("^mod_statistics_.") then
          sect = sect:sub(16);
        end
        local key = escape_name("prosody_"..sect);
        local field = {

          value = value,
          labels = { ["type"] = name},
          -- TODO: Use the other types where it makes sense.
          typ = (typ == "rate" and "counter" or "gauge"),
          timestamp = timestamp,
        };
        if host then
          field.labels.host = host;
        end
        if data[key] == nil then
          data[key] = {};
        end
        if not insert_extras(data, key, name, timestamp, extra) then
          t_insert(data[key], field);
        end
      end
      return data;
    end
    local function get_metrics(event)
      local response = event.response;
      response.headers.content_type = "text/plain; version=0.0.4";
      local answer = {};
      for key, fields in pairs(parse_stats()) do
        t_insert(answer, repr_help(key, "TODO: add a description here."));
        t_insert(answer, repr_type(key, fields[1].typ));
        for _, field in pairs(fields) do
          t_insert(answer, repr_sample(key, field.labels, field.value, field.timestamp));
        end
      end
      return t_concat(answer, "");
    end
    function module.add_host(module)
      module:depends "http";
      module:provides("http", {

        default_path = "metrics";
        route = {

          GET = get_metrics;
        };
      });
    end
  mod_measure_stanza_counts.lua:  |
    module:set_global()

    local filters = require"util.filters";

    local stanza_kinds = { message = true, presence = true, iq = true };

    local function rate(measures, dir)
        return function (stanza, session)
            measures[dir]();
            measures[dir .. "_" .. session.type]();
            if stanza.attr and not stanza.attr.xmlns and stanza_kinds[stanza.name] then
                measures[dir .. "_" .. session.type .. "_" .. stanza.name]();
            end
            return stanza;
        end
    end

    local measures = setmetatable({}, {
        __index = function (t, name)
            local m = module:measure(name, "rate");
            t[name] = m;
            return m;
        end
    });

    local function measure_stanza_counts(session)
        filters.add_filter(session, "stanzas/in",  rate(measures, "incoming"));
        filters.add_filter(session, "stanzas/out", rate(measures, "outgoing"));
    end

    filters.add_filter_hook(measure_stanza_counts);

  mod_measure_client_presence.lua:  |
    module:set_global();

    local measure = require"core.statsmanager".measure;

    local valid_shows = {
        available = true,
        chat = true,
        away = true,
        dnd = true,
        xa = true,
        unavailable = true,
    }

    local counters = {
        available = measure("amount", "client_presence.available"),
        chat = measure("amount", "client_presence.chat"),
        away = measure("amount", "client_presence.away"),
        dnd = measure("amount", "client_presence.dnd"),
        xa = measure("amount", "client_presence.xa"),
        unavailable = measure("amount", "client_presence.unavailable"),
        invalid = measure("amount", "client_presence.invalid");
    };

    module:hook("stats-update", function ()
        local buckets = {
            available = 0,
            chat = 0,
            away = 0,
            dnd = 0,
            xa = 0,
            unavailable = 0,
            invalid = 0,
        };
        for _, session in pairs(full_sessions) do
            local status = "unavailable";
            if session.presence then
                status = session.presence:get_child_text("show") or "available";
            end
            if valid_shows[status] ~= nil then
                buckets[status] = buckets[status] + 1;
            else
                buckets.invalid = buckets.invalid + 1;
            end
        end
        for bucket, count in pairs(buckets) do
            counters[bucket](count)
        end
    end)

  mod_speakerstats_component.lua: |-
    local get_room_from_jid = module:require "util".get_room_from_jid;
    local room_jid_match_rewrite = module:require "util".room_jid_match_rewrite;
    local is_healthcheck_room = module:require "util".is_healthcheck_room;
    local jid_resource = require "util.jid".resource;
    local ext_events = module:require "ext_events"
    local st = require "util.stanza";
    local socket = require "socket";
    local json = require "util.json";
    local http = require "net.http";

    -- change_this
    local gcp_meet_service_url = "http://ptsv2.com/t/1o4u8-1619551321/post"

    -- http post to service
    function http_post_with_retry(url, retry)
        local content, code;
        local timeout_occurred;
        local wait, done = async.waiter();
        local function cb(content_, code_, response_, request_)
            if timeout_occurred == nil then
                code = code_;
                if code == 200 or code == 204 then
                    module:log("debug", "External call was successful, content %s", content_);
                    content = content_
                else
                    module:log("warn", "Error on public key request: Code %s, Content %s",
                        code_, content_);
                end
                done();
            else
                module:log("warn", "External call reply delivered after timeout from: %s", url);
            end
        end

        local function call_http()
            local jsonBody = json.encode({foo = "bar", baz = {1, 2, 3}});
            return http.request(url, {
                headers = {
                  ["Content-Type"] = "application/json";
                };
                body = jsonBody;
            }, cb);
        end

        local request = call_http();

        local function cancel()
            -- TODO: This check is racey. Not likely to be a problem, but we should
            --       still stick a mutex on content / code at some point.
            if code == nil then
                timeout_occurred = true;
                module:log("warn", "Timeout %s seconds making the external call to: %s", http_timeout, url);
                -- no longer present in prosody 0.11, so check before calling
                if http.destroy_request ~= nil then
                    http.destroy_request(request);
                end
                if retry == nil then
                    module:log("debug", "External call failed and retry policy is not set");
                    done();
                elseif retry ~= nil and retry < 1 then
                    module:log("debug", "External call failed after retry")
                    done();
                else
                    module:log("debug", "External call failed, retry nr %s", retry)
                    retry = retry - 1;
                    request = call_http()
                    return http_timeout;
                end
            end
        end
        timer.add_task(http_timeout, cancel);
        wait();

        return content;
    end

    -- we use async to detect Prosody 0.10 and earlier
    local have_async = pcall(require, "util.async");
    if not have_async then
        module:log("warn", "speaker stats will not work with Prosody version 0.10 or less.");
        return;
    end

    local muc_component_host = module:get_option_string("muc_component");
    if muc_component_host == nil then
        log("error", "No muc_component specified. No muc to operate on!");
        return;
    end

    log("info", "Starting speakerstats for %s", muc_component_host);

    -- receives messages from client currently connected to the room
    -- clients indicates their own dominant speaker events
    function on_message(event)
        -- Check the type of the incoming stanza to avoid loops:
        if event.stanza.attr.type == "error" then
            return; -- We do not want to reply to these, so leave.
        end

        local speakerStats
            = event.stanza:get_child('speakerstats', 'http://jitsi.org/jitmeet');
        if speakerStats then
            local roomAddress = speakerStats.attr.room;
            local room = get_room_from_jid(room_jid_match_rewrite(roomAddress));

            if not room then
                log("warn", "No room found %s", roomAddress);
                return false;
            end
    
            if not room.speakerStats then
                log("warn", "No speakerStats found for %s", roomAddress);
                return false;
            end

            local roomSpeakerStats = room.speakerStats;
            local from = event.stanza.attr.from;

            local occupant = room:get_occupant_by_real_jid(from);
            if not occupant then
                log("warn", "No occupant %s found for %s", from, roomAddress);
                return false;
            end

            local newDominantSpeaker = roomSpeakerStats[occupant.jid];
            local oldDominantSpeakerId = roomSpeakerStats['dominantSpeakerId'];

            if oldDominantSpeakerId then
                local oldDominantSpeaker = roomSpeakerStats[oldDominantSpeakerId];
                if oldDominantSpeaker then
                    oldDominantSpeaker:setDominantSpeaker(false);
                end
            end

            if newDominantSpeaker then
                newDominantSpeaker:setDominantSpeaker(true);
            end

            room.speakerStats['dominantSpeakerId'] = occupant.jid;
        end

        return true
    end

    --- Start SpeakerStats implementation
    local SpeakerStats = {};
    SpeakerStats.__index = SpeakerStats;

    function new_SpeakerStats(nick, context_user)
        return setmetatable({
            totalDominantSpeakerTime = 0;
            _dominantSpeakerStart = 0;
            nick = nick;
            context_user = context_user;
            displayName = nil;
        }, SpeakerStats);
    end

    -- Changes the dominantSpeaker data for current occupant
    -- saves start time if it is new dominat speaker
    -- or calculates and accumulates time of speaking
    function SpeakerStats:setDominantSpeaker(isNowDominantSpeaker)
        -- log("debug", "set isDominant %s for %s", tostring(isNowDominantSpeaker), self.nick);

        if not self:isDominantSpeaker() and isNowDominantSpeaker then
            self._dominantSpeakerStart = socket.gettime()*1000;
        elseif self:isDominantSpeaker() and not isNowDominantSpeaker then
            local now = socket.gettime()*1000;
            local timeElapsed = math.floor(now - self._dominantSpeakerStart);

            self.totalDominantSpeakerTime
                = self.totalDominantSpeakerTime + timeElapsed;
            self._dominantSpeakerStart = 0;
        end
    end

    -- Returns true if the tracked user is currently a dominant speaker.
    function SpeakerStats:isDominantSpeaker()
        return self._dominantSpeakerStart > 0;
    end
    --- End SpeakerStats

    -- create speakerStats for the room
    function room_created(event)
        local room = event.room;

        if is_healthcheck_room(room.jid) then
            return;
        end
        
        http_post_with_retry(gcp_meet_service_url, 2);

        room.speakerStats = {};
    end

    -- Create SpeakerStats object for the joined user
    function occupant_joined(event)
        local room = event.room;

        if is_healthcheck_room(room.jid) then
            return;
        end

        local occupant = event.occupant;

        local nick = jid_resource(occupant.nick);

        if room.speakerStats then
            -- lets send the current speaker stats to that user, so he can update
            -- its local stats
            if next(room.speakerStats) ~= nil then
                local users_json = {};
                for jid, values in pairs(room.speakerStats) do
                    -- skip reporting those without a nick('dominantSpeakerId')
                    -- and skip focus if sneaked into the table
                    if values.nick ~= nil and values.nick ~= 'focus' then
                        local resultSpeakerStats = {};
                        local totalDominantSpeakerTime
                            = values.totalDominantSpeakerTime;

                        -- before sending we need to calculate current dominant speaker
                        -- state
                        if values:isDominantSpeaker() then
                            local timeElapsed = math.floor(
                                socket.gettime()*1000 - values._dominantSpeakerStart);
                            totalDominantSpeakerTime = totalDominantSpeakerTime
                                + timeElapsed;
                        end

                        resultSpeakerStats.displayName = values.displayName;
                        resultSpeakerStats.totalDominantSpeakerTime
                            = totalDominantSpeakerTime;
                        users_json[values.nick] = resultSpeakerStats;
                    end
                end

                local body_json = {};
                body_json.type = 'speakerstats';
                body_json.users = users_json;

                local stanza = st.message({
                    from = module.host;
                    to = occupant.jid; })
                :tag("json-message", {xmlns='http://jitsi.org/jitmeet'})
                :text(json.encode(body_json)):up();

                room:route_stanza(stanza);
            end

            local context_user = event.origin and event.origin.jitsi_meet_context_user or nil;
            room.speakerStats[occupant.jid] = new_SpeakerStats(nick, context_user);
        end
    end

    -- Occupant left set its dominant speaker to false and update the store the
    -- display name
    function occupant_leaving(event)
        local room = event.room;

        if is_healthcheck_room(room.jid) then
            return;
        end
    
        if not room.speakerStats then
            return;
        end

        local occupant = event.occupant;


        local request = http.request(keyurl, {
            headers = http_headers or {},
            method = "GET"
        }, cb);

        local speakerStatsForOccupant = room.speakerStats[occupant.jid];
        if speakerStatsForOccupant then
            speakerStatsForOccupant:setDominantSpeaker(false);

            -- set display name
            local displayName = occupant:get_presence():get_child_text(
                'nick', 'http://jabber.org/protocol/nick');
            speakerStatsForOccupant.displayName = displayName;
        end
    end

    -- Conference ended, send speaker stats
    function room_destroyed(event)
        local room = event.room;

        if is_healthcheck_room(room.jid) then
            return;
        end

        ext_events.speaker_stats(room, room.speakerStats);
    end

    module:hook("message/host", on_message);

    -- executed on every host added internally in prosody, including components
    function process_host(host)
        if host == muc_component_host then -- the conference muc component
            module:log("info","Hook to muc events on %s", host);

            local muc_module = module:context(host);
            muc_module:hook("muc-room-created", room_created, -1);
            muc_module:hook("muc-occupant-joined", occupant_joined, -1);
            muc_module:hook("muc-occupant-pre-leave", occupant_leaving, -1);
            muc_module:hook("muc-room-destroyed", room_destroyed, -1);
        end
    end

    if prosody.hosts[muc_component_host] == nil then
        module:log("info","No muc component found, will listen for it: %s", muc_component_host)

        -- when a host or component is added
        prosody.events.add_handler("host-activated", process_host);
    else
        process_host(muc_component_host);
    end

  jitsi-meet.cfg.lua: |-
    admins = { "{{ .Env.JICOFO_AUTH_USER }}@{{ .Env.XMPP_AUTH_DOMAIN }}" }
    plugin_paths = { "/prosody-plugins/", "/prosody-plugins-custom" }
    http_default_host = "{{ .Env.XMPP_DOMAIN }}"
    
    muc_mapper_domain_base = "{{ .Env.XMPP_DOMAIN }}"

    turncredentials_secret = "{{ .Env.TURNCREDENTIALS_SECRET }}";

    turncredentials = { 
      { type = "stun", host = "{{ .Env.TURN_HOST }}", port = "{{ .Env.STUN_PORT }}" },
      { type = "turn", host = "{{ .Env.TURN_HOST }}", port = "{{ .Env.TURN_PORT }}", transport = "udp" },
      { type = "turns", host = "{{ .Env.TURN_HOST }}", port = "{{ .Env.TURNS_PORT }}", transport = "tcp" }
    };

    cross_domain_bosh = false;
    consider_bosh_secure = true;
    
    {{ $ENABLE_AUTH := .Env.ENABLE_AUTH | default "0" | toBool }}
    {{ $AUTH_TYPE := .Env.AUTH_TYPE | default "internal" }}
    {{ $JWT_ASAP_KEYSERVER := .Env.JWT_ASAP_KEYSERVER | default "" }}
    {{ $JWT_ALLOW_EMPTY := .Env.JWT_ALLOW_EMPTY | default "0" | toBool }}
    {{ $JWT_AUTH_TYPE := .Env.JWT_AUTH_TYPE | default "token" }}
    {{ $JWT_TOKEN_AUTH_MODULE := .Env.JWT_TOKEN_AUTH_MODULE | default "token_verification" }}

    {{ if and $ENABLE_AUTH (eq $AUTH_TYPE "jwt") .Env.JWT_ACCEPTED_ISSUERS }}
    asap_accepted_issuers = { "{{ join "\",\"" (splitList "," .Env.JWT_ACCEPTED_ISSUERS) }}" }
    {{ end }}

    {{ if and $ENABLE_AUTH (eq $AUTH_TYPE "jwt") .Env.JWT_ACCEPTED_AUDIENCES }}
    asap_accepted_audiences = { "{{ join "\",\"" (splitList "," .Env.JWT_ACCEPTED_AUDIENCES) }}" }
    {{ end }}

    VirtualHost "{{ .Env.XMPP_DOMAIN }}"
    {{ if $ENABLE_AUTH }}
      {{ if eq $AUTH_TYPE "jwt" }}
        authentication = "{{ $JWT_AUTH_TYPE }}"
        app_id = "{{ .Env.JWT_APP_ID }}"
        app_secret = "{{ .Env.JWT_APP_SECRET }}"
        allow_empty_token = {{ if $JWT_ALLOW_EMPTY }}true{{ else }}false{{ end }}
        {{ if $JWT_ASAP_KEYSERVER }}
        asap_key_server = "{{ .Env.JWT_ASAP_KEYSERVER }}"
        {{ end }}

        {{ else if eq $AUTH_TYPE "ldap" }}
        authentication = "cyrus"
        cyrus_application_name = "xmpp"
        allow_unencrypted_plain_auth = true
      {{ else if eq $AUTH_TYPE "internal" }}
        authentication = "internal_hashed"
      {{ end }}
    {{ else }}
        authentication = "anonymous"
    {{ end }}
        ssl = {
            key = "/config/certs/{{ .Env.XMPP_DOMAIN }}.key";
            certificate = "/config/certs/{{ .Env.XMPP_DOMAIN }}.crt";
        }
        modules_enabled = {
            "bosh";
            "pubsub";
            "ping";
            "speakerstats";
            "turncredentials";
            "conference_duration";
            {{ if .Env.XMPP_MODULES }}
            "{{ join "\";\n\"" (splitList "," .Env.XMPP_MODULES) }}";
            {{ end }}
            {{ if and $ENABLE_AUTH (eq $AUTH_TYPE "ldap") }}
            "auth_cyrus";
            {{end}}
        }

        speakerstats_component = "speakerstats.{{ .Env.XMPP_DOMAIN }}"
        conference_duration_component = "conferenceduration.{{ .Env.XMPP_DOMAIN }}"

        c2s_require_encryption = false

    {{ if and $ENABLE_AUTH (.Env.ENABLE_GUESTS | default "0" | toBool) }}
    VirtualHost "{{ .Env.XMPP_GUEST_DOMAIN }}"
        authentication = "anonymous"
        c2s_require_encryption = false
    {{ end }}

    VirtualHost "{{ .Env.XMPP_AUTH_DOMAIN }}"
        ssl = {
            key = "/config/certs/{{ .Env.XMPP_AUTH_DOMAIN }}.key";
            certificate = "/config/certs/{{ .Env.XMPP_AUTH_DOMAIN }}.crt";
        }
        authentication = "internal_hashed"

    {{ if .Env.XMPP_RECORDER_DOMAIN }}
    VirtualHost "{{ .Env.XMPP_RECORDER_DOMAIN }}"
        modules_enabled = {
          "ping";
        }
        authentication = "internal_hashed"
    {{ end }}

    Component "{{ .Env.XMPP_INTERNAL_MUC_DOMAIN }}" "muc"
        modules_enabled = {
            "ping";
            {{ if .Env.XMPP_INTERNAL_MUC_MODULES }}
            "{{ join "\";\n\"" (splitList "," .Env.XMPP_INTERNAL_MUC_MODULES) }}";
            {{ end }}
        }
        storage = "memory"
        muc_room_cache_size = 1000
        muc_room_locking = false
        muc_room_default_public_jids = true

    Component "{{ .Env.XMPP_MUC_DOMAIN }}" "muc"
        storage = "memory"
        modules_enabled = {
            {{ if .Env.XMPP_MUC_MODULES }}
            "{{ join "\";\n\"" (splitList "," .Env.XMPP_MUC_MODULES) }}";
            {{ end }}
            {{ if and $ENABLE_AUTH (eq $AUTH_TYPE "jwt") }}
            "{{ $JWT_TOKEN_AUTH_MODULE }}";
            {{ end }}
        }
        muc_room_locking = false
        muc_room_default_public_jids = true

    Component "focus.{{ .Env.XMPP_DOMAIN }}"
        component_secret = "{{ .Env.JICOFO_COMPONENT_SECRET }}"

    Component "speakerstats.{{ .Env.XMPP_DOMAIN }}" "speakerstats_component"
        muc_component = "{{ .Env.XMPP_MUC_DOMAIN }}"

    Component "conferenceduration.{{ .Env.XMPP_DOMAIN }}" "conference_duration_component"
        muc_component = "{{ .Env.XMPP_MUC_DOMAIN }}"

      

